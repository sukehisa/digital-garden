---
aliases: []
tags: []
publish: true
date: 2023-07-01T10:24:26+09:00
updated: 2023-07-01T10:25:17+09:00
---

# SI　テスト
## 良いテストケースの条件
* テスト要件とのトレースがとりやすい ⇒ テスト要件のカバレッジがわかる
* どこに何が書いてあるかわかりやすくする ⇒ テストケースの漏れや重複を起こしにくくする
* 適切な細かさで記載しやすくする ⇒ 誰がやっても同じテスト結果になる
* 修正しやすい ⇒ 追加・変更しやすいテスト仕様
* テスト実施結果(ログ)を残しやすい ⇒ 最新の情報に更新される頻度が早くなる
* テスト消化率のとりやすいしくみがある ⇒ テスト実施の進捗を把握できる

[NOTE]
出典：ソフトウェア・テスト PRESS Vol.1 

Test Management Tool
- <https://en.wikipedia.org/wiki/Test_management_tool#List_of_test_management_tools[Test> management tool - Wikipedia]

# ソフトウェアテスト　（一般論として）
## 良さそうな文献
* The Art of Software Testing
* ソフトウェアテスト293の鉄則
* システムテスト自動化 標準ガイド
* IEEE829


## 定義
テストとは
- ”実際どうなっているか”と”本来はどうあるべきか”を比較するプロセスのこと
- IEEE Standard Glossary of Software Engineering Terminologyによる定義
```
ある特定の条件下でシステムまたはコンポーネントを操作するプロセスであり、その結果を観察または記録して、システムまたはコンポーネントのある側面を評価すること
```
ここでいう”ある特定の条件”を具体化したものがテストケースである

- Systematic Software Testingによる定義
```
テストとは、テストされるソフトウェアの品質を測定して改善するために、テストウェアをエンジニアリングし、利用し、保守しながら、同時並行的に進めるライフサイクルプロセスである
```
テストには、実行だけでなく、計画・分析・テストケース設計の観点も必要である


## ブラックボックステスト
### 同値クラステスト
* 十分なテストカバレッジを保ちつつ、ケース数を削減する技法のこと
* 同値クラス：有るコードパスを通る値のグルーピング
** ある同値クラス内のテストケースで欠陥が検出された場合、同じ同値クラス内の他のテストケースでも同じく欠陥が発生する。(欠陥が発生しない場合は、すべてで発生しない)
* 方法

1. 同値クラスが何かを識別する
2. 各同値クラスにつき、テストケースを1つ作成する
3. (オプション)リソースに余裕があれば、同じ同値クラスに複数のテストケースを設定する。但し、適切に同値クラスが識別されていれば、1つ目のケースで発見できなかった欠陥を見つけることは無い。
テストケースは、アプローチによって有効値/無効値の入力をテストする

* 同値クラステストは、単体テスト、統合テスト、システムテスト、受け入れテストのそれぞれに同じ様に適用できる

* 無効な入力値に対してテストケースを作成する必要があるか？？
** 事前条件がtaken/untakenの時のテストに対する、事後条件のテスト有無によって、契約と防御的設計の2つに分けられる
** アプローチ1：契約による設計(事前条件がtakenの場合のみを想定)
*** 事前条件が満足された状況でのテストケースしか作成しないというアプローチ(e.g. ファイルが存在しなければ(事前条件)、file open(事後条件)のテストは行わない)
** アプローチ2：防御的設計
*** モジュールはどんな入力でも受け付けるように設計される
*** 正常な事前条件が満たされない場合に、モジュールはエラーコードを返したり例外を発生させる
* 複数入力での無効値のテストでは、1回のテストで1つの無効値をテストすること
** 1つの入力値が無効値で、別の項目のエラーを覆い隠すことがあるため。というか、科学的なアプローチとして、同時に変えて良い変数は1つだけ！
* 発生し得る入力値を要件定義・設計の段階で減らす事は、テスト削減につながる
** e.g. 入力値をラジオボタンにする
* 1つのテストケースで複数の入力項目をテストできるようにすると効率的である

### 境界値テスト
* 境界にはたくさんの欠陥が潜んでいる
* 方法

1. 同値クラスを見つける
2. 同値クラスの境界を見つける
3. 各境界について、境界上の値、境界上のすぐ下、すぐ上の値を選んでテストケースを作る

* ある同値クラスに対する、境界値テストが、別の同値クラスのテストになることもあるが、その場合は不要(重複実施する必要は無い)

### ディシジョンテーブルテスト
* デシジョンテーブル：システムが実装する、ビジネスルールを記録するためのもの。
** 入力の条件組合せと、紐づくアクションを定義する
* デシジョンテーブルは、テストケースを作成するための指針としても役立つ
* 各ルールに対して、少なくとも1つのテストケースを作成する必要がある。ルールの条件が2値の場合、各組み合わせに対して1つのテストケースを用意すれば十分。条件が値の範囲の場合は、境界値テストの考え方を統合する
* デシジョンテーブルの論理圧縮
** アクションがある条件に依存する場合、他の条件はDon't Careにできるため、テーブル論理を圧縮でき、開発は楽ができる
** しかし、テストにおいては、誤ったデシジョンテーブルの論理圧縮をしていないかをテストするために、圧縮をしないデシジョンテーブルをもとにしてテストケースを作るべきである

### ペア構成テスト
* 複数の入力値と、各入力値のテストする値の数について、全パターンをテストしようとすると、テストケース数が爆発する
* 品質をできるだけ落とさずに、テストを圧縮したいというのがモチベーション
** 感覚的には、1〜20％のテストケースの作成・実行で、全欠陥の70〜85％を検出できるといった感じ
* 単体・統合・システム・受け入れテストそれぞれに適用可能
* シングルモード欠陥とダブルモード欠陥をすべてテスト可能なテストケースの最小セットを定義する
** ほとんどの欠陥はこの2つの欠陥タイプであると仮定できるため、実際に欠陥を高い確率で検出出来ている

* 直交表を使う方法と、アルゴリズムで組合せを生成する、2つの方法がある
** 直交表
*** どの任意の2列を選んでも、すべての値ペアの組合せが現れる表のこと
*** 対象のモジュールに合う直交表を探し、テストケースを割り付ける(ルールあり)
** 全ペアアルゴリズム(オールペア法、Allpairs)
*** アルゴリズムで生成。均衡である直交表と違うため、ケース数は直交表よりも減る
*** 状況によっては組合せに制約条件があり、特定の変数の組み合わせは選択できないことが有る(e.g. IEとMacOS)。その場合は、制約条件を定義すれば、ツールがそれを考慮してペアを選択するものも有る
**** rdExpert, AETG
** 直交表では、結果としてダブルモード欠陥よりも複雑な欠陥を一定量カバーしており、全ペアアルゴリズムよりもカバレッジは高くなる
** 当然、特定の非常に重要な組合せがあれば、自分の判断でテストケースを追加してもよい

#### ツール
* All Pairs test case Generation Tool
** <http://satisfice.com/tools.shtml[Test> Tools - James Bach - Satisfice, Inc.]


### 状態遷移図テスト
* 状態遷移図の構成要素：状態、イベント、アクション
** 1つのエンティティについて、1つの状態遷移図
*** 複数の異なるエンティティを混在させないこと
** 対象のエンティティにおけるすべての可能性がある状態、イベント、遷移を表す
* 状態遷移図から状態遷移表を作れる
** ある行が持つ列は、現在の状態、イベント/アクション、次の状態 
* 状態遷移表からテストケースを作る
** 最も望ましいのは、すべてのパスが少なくとも1回は実行されるようなケースを作成すること
*** 状態遷移図がループを持っている場合は無限になってしまう・・・
** 他には、全ての遷移を少なくとも1回はテストするケースを作成するというアプローチ
*** 一般的にはこのレベルが推奨される
*** 状態遷移表がそのままテストケースになる


###= ドメイン分析テスト
* 同時に複数の変数をテストする方法
** すべての変数のために個別のテストケースを作成するには、あまりに多すぎて、時間が足りない
** 同値クラステストや境界値テストを一般化したもの
** 不等式条件や等値条件で、on/offポイントを検査するようにテストケースを設定する。対象外の変数は、条件を満たす代表値を使用する。

### ユースケーステスト
* 個別のトランザクションを1つ1つテストすることで、システムの機能を最初から最後まで通しで実行するようなテストケース設計方法
* ユースケースはUMLなどで定義される
* システムテストと受け入れテストのテストケースを開発するための基盤として役立つ

## ホワイトボックステスト
* 適用対象は単体・統合・システムテスト
* 対象ソフトウェアの内部パス・構造・実装に関する知識を拠り所にしたテスト戦略
* 本質は、コードのテストというよりもパスのテスト
** モジュール内のパスのテスト(単体)、サブシステム内のモジュール間、システム内のサブシステム間のパス、システム間のパスのテスト、というように拡張できる

### 制御フローテスト
* モジュール内の実行パスを識別して、パスを網羅するようにテストケースを作成して実行する
* パスの数がとてつもなく大きくなる可能性あり
** e.g. 条件分岐1つにつき、2倍になっていく・・
** 要件を満たさずに誤って実装された場合、それは当然検知できない(誤った実装からテストを生成するため)
* モジュールを制御フローグラフで表現する

カバレッジレベル
- ステートメントカバレッジ
	- 全てのステートメントが少なくとも1回実行される
- ディシジョンカバレッジ(ブランチカバレッジ)
	- 全ての条件判定に対してTrue, Falseを少なくとも1回ずつ
- コンデションカバレッジ
	- 全ての条件がTrue/Falseの判定結果に少なくとも1回ずつなるように
- 複合コンディションカバレッジ
- パスカバレッジ
	- 全てのパスを1回通るようにケースを生成する

* 構造化テスト/基礎パステスト
** サイクロマチック数：直列の組合せでモジュールを通過するすべての可能な、独立でループを含まないパス(基礎パス)を生成できる
** サイクロマチック数分のテストケースを生成する
** 制御フローグラフ上の全てのノード、リンクをカバーするため、ステートメントカバレッジとディシジョンカバレッジを満たす

### データフローテスト
* データのライフサイクル(定義:d、使用:u、消滅:k)で、時系列にチェックする
** 定義・使用・消滅のパターンが正しいかを確認する
*** e.g. ku(消滅した後に使用)は、欠陥
* データフロータイアグラムで、モジュールの全ての変数に対して、定義・使用・消滅の状態を記述する


## テストパラダイム
- テストのパラダイムは、スクリプトテストと探索的テストの2つ。(全く異なるパラダイム)
	- 現場ではこの2つのミックスとなることが多い

### テストに対するアプローチ
- 非特定不具合モデル
	- 欠陥の分類を使わない方法。要件及び仕様から全てのテストケースを作成する

- 特定不具合モデル
	- 欠陥の分類にもとづいてテストケースを作成する。以前に経験したことの有る欠陥に似た不具合を発見できるようにテストケースを作成。

 - 欠陥の分類: ソフトウェアにおける欠陥の分類
	- Beizerによる分類
	- Kaner, Falk, Nguyenによる分類

### スクリプトテスト
* テストを設計し、テストケースを文書化し、テストケースを実行する
* 再現性、客観性、監査性が求められる場合に利用する
* 再現性：誰が実行しても同じ方法で実行できる状態でテストが定義されていること
* 客観性：テストケースを作成した人に依存しなこと
* 監査性：要件・設計・コード→テストケースに対して、トレーサビリティが存在すること
* IEEE829「Standard for Software Test Documentation」

### 探索的テスト
* 製品について学習し、テストを設計し、テストを実行する
* James Bach「テスト設計とテスト実行の同時並行的な学習行為」
* 次に実行すべきテストケースを事前に計画しきらずに、むしろ1つ前に実行したテストとその結果から、次のテストを設計していく
* 要件が曖昧・存在しない時、システムが不安定など、短い時間内にテストしてフィードバックをする場合に役立つ
* スクリプトテストがエラーを検出できなくなった場合に、補完するものとして役立つ

# テストを計画する
## 原則
- テストは負債である
- 100%のテスト網羅率を得ることは目標にすべきことではない。
## テスト計画に必要な要素
- プロダクションコードの種類の識別
- テストピラミッド（テスト工程・種類）とSUTの境界線
- テストケースの洗い出し方（テスト観点）、テストの実行方式
- テストデータ

## プロダクションコードの分類
- 分類の軸
	- コードの複雑さ or ドメインにおける重要性
		- 複雑さ：　分岐の数で計測。多いほど複雑度が高い
		- ドメインにおける重要性：　エンドユーザが求めていることに直接結びつくか？　（例えば、ユーティリティは結びつかない）
	- 協力者オブジェクトの数
- 4種類のプロダクションコード
![[Pasted image 20230930090439.png]]
- ドメインモデル・アルゴリズム：
- コントローラ：　ビジネス的に重要なことは行わないが、複数のコンポーネント（e.g. ドメインクラスや外部のアプリケーション）が適切に連携できるように調整する
- 過度に複雑なコード：　理想としては存在させない。　コントローラとドメインモデルに分割を検討する

## テストの種類
| 種類                          | 説明 | 検証の対象   |
| ----------------------------- | ---- | --- |
| Unit Testing (単体テスト)     | 3つの性質を持つ： 単体（Unit）　となる少量のコードを検証すること、実行時間が短いこと、隔離された状態で実行されること     | ドメインモデル、アルゴリズム    |
| Integration Test (統合テスト) |  単体テストの持つ３つの性質のうち、１つでも損なっている場合は、統合テストである     | コントローラ    |
| E2E (End-to-End)              |      |     |
|                               |      |     | 

- システムテスト
	- 非機能要件をテストする
- 
- その他
	- 本番環境テスト
		- Readトラフィックはできるが、Writeトラフィックはケアが必要
	- スモークテスト, Smoke Testing
		- 実際に動かしてみて、煙が出ない程度に最低限動作することを確認するテストのことです
	- Visual Regression Testing
		- UI向け
		- [What is Visual Regression Testing? Tools & Examples \- Applitools](https://applitools.com/blog/visual-regression-testing/)

## テストピラミッド
![[Pasted image 20230930091438.png]]
- 単体テストではビジネスシナリオにおける以上ケースをできるだけ多く検証し、「結合テスト」では、1件のhappy pathと単体テストでは検証できない全ての異常ケースを検証することが適切だと考えられている
- ドメインモデル（ビジネスロジック、複雑さを扱う層）　は単体テスト　でテストし、コントローラに対する検証は統合テストで行う
- モックの利用は統合テストに限定する
	- ビジネスロジック　と　連携を指揮する（コントローラ）　部分を分離する　という基本原則が前提
	- 

# Unit Testing
## 単体テストとは
単体テストの定義とはなんでしょうか？下記のような性質を持つものと定義されます。
- 単体（Unit）　となる少量のコードを検証すること
- 実行時間が短いこと
- 隔離された状態で実行されること

良い単体テスト　はどのような性質を持つでしょうか？
- １単位の振る舞い（a unit of behavior) （≒最終的な結果/アウトプット）　が検証されていること
	- 検証対象は`観察可能な振る舞い`とし、その結果を得るための細かい手順である実装の詳細には目を向けないようにする
		- アプリケーションの振る舞いについてより高いレベルで描写するべきである（≠プロダクションコードが何をするのかを単に列挙する）
		- 検証対象がクライアントにとって意味のある結果であることで、ビジネス的観点において必要なことと結びつくようになる。
			- テストケースで語られることはドメインエキスパートが理解できることにする必要がある。それができない場合は、実装の詳細に強く結びついていると言える
		- 開発者はクライアントへの影響があるため、テストの失敗に敏感になる
	- テストケース作成には`ブラックボックステスト`を用いること。　テストケースの分析（カバレッジなど）にはホワイトボックステストを使用できる
	- プロダクションコードに密接に結びつけてはならない。仕様を変えないリファクタリングでも、テストコードが失敗する
		- リファクタリングとは、アプリケーションの観察可能な振る舞いを変えずに実装を変えることである

==観察可能な振る舞いとは?==
すべてのプロダクションコードは次の２つの観点で分類が可能
- 公開されたAPI　か　プライベートなAPIか？
	- e.g. public vs private
- 観察可能な振る舞い(Observable behavior)　か　実装の詳細(Implementation detail)か？
	- APIクライアントが目標を達成するために使う公開された操作・状態　が　観察可能な振る舞い
		- クライアントが達成しようとしている目標の中の少なくとも１つに、そのAPIが直接的に関係していないといけない
	- それ以外は実装の詳細である
良く設計されたシステムの場合
- 公開されたAPIは観察可能な振る舞い　であり、　実装の詳細はプライベートなAPI　として隠蔽する
Hexagonal Architectureを考えてみると
- 外部クライアント　→|　アプリケーションサービス層　→　ドメイン層（ビジネスロジック） |
- アプリケーションサービス層に対するテストケースでは、ビジネスにおける全体的なユースケース　が検証される
- ドメイン層に対するテストケースでは、全体的なユースケースで達成しようとしている目標　がドメイン層で分割された　一部の目標　が検証される


良い単体テストを構成する柱
- リグレッション（退行）に対する保護
- リファクタリングへの耐性
	- 基本的に、単体テストに対しては、耐性が有るか無いか　の２状態しかない。最大限に持たせるべき柱
	- False Positive（正しい振る舞いだが、テストケースが失敗する）を増えることで、耐性が失われる。
	- False Positiveを生み出す最大の原因は、テストケースが実装の詳細と紐づいてしまうこと
		- 検証すべきは、What であり、 Howではない
	- False Positiveが少ないことで、リグレッションに対するマインドが維持される
- 迅速なフィードバックが得られること
- 保守がしやすいこと
	- テストケースを理解することがどれくらい難しいか？
	- テストを行うことがどれくらい難しいか？
		- プロセス外依存の存在など

「単体テスト」自体はどのような性質を持つでしょうか？
- プロダクションコードの欠点を見つけ出すことが得意であること
	- 例えば、あなたのテストコードの準備（Arrange)フェーズがあまりにも大きい場合、それは何らかの設計問題がある可能性が高い　（複雑な依存関係が必要になる）

## SUT と 依存
”単体”をテストするために、テスト対象の単体（SUT）と”依存”を区別する必要があります。この依存はどのように種類分けできるでしょうか？
- 共有依存
	- 複数のテストケースで使われている依存（≠プロダクションコード間で共有される依存）
- プライベート依存
	- 共有されていない依存
- プロセス外依存
	- SUTを実行しているプロセスとは異なるプロセスでホストされている依存（e.g. DB, メッセージバス、メースサービス）

また、各依存の性質　として下記軸が存在します。
- 依存のmutability
	- 不変 or 可変　依存
- 依存の所在
	- プロセス内 or 外　依存
	- プロセス外の例: データベース、ファイルシステム、外部API

| 例                             | 依存の種類   | 依存のmutability | プロセス内外 |
| ------------------------------ | ------------ | ---------------- | ------------ |
| Singleton, staticフィールド    | 共有依存     | Immutable        | プロセス内   |
| Database                       | 共有依存     | Mutable          | プロセス外   |
| ※単体テストとしてはあまりない。ほとんどはMutable | 共有依存     | Immutable        | プロセス外   |
| ※実際のPRJではほぼ無いはず     | 共有依存     | Mutable          | プロセス内   |
|                                | プライベート | Immutable        | プロセス内   |
|                                | プライベート | Mutable          | プロセス外   |
| 読み取り専用API                | プライベート | Immutable        | プロセス外   |
|                                | プライベート | Mutable          | プロセス内   |

## 古典学派 vs ロンドン学派
違いを理解するための考え方の軸
- 単体テストはプロダクションコードをどのくらい把握してないといけないのか？

| topic                         | 古典学派                                                                                                                  | ロンドン学派                                                                                                                                     |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| "単体"の定義/隔離の範囲の定義 | 1単位の"振る舞い"。テストケースそれぞれを隔離する。他のテストケースの実行に影響する共有依存のみをテストダブルに置き換える | 1単位の"コード" ≒クラス。不変依存以外の依存をテストダブルに置き換える                                                                            |
| テストダブル置き換えについて  |                                                                                                                           | ドメイン層のクラス同士のコミュニケーションに対する検証であっても、テストダブルを使用する必要があり、テストケースが実装の詳細と結びついてしまう。 |



## 前提、原則
- テストコードを含めたすべてのコードは`負債`である
	- テストケースがもたらす価値の基準を高く設定すべきである。あまり価値のないテストケースをいくつも用意するのではなく、価値のあるテストケースを必要な文だけテストスイートに含めるべきである。

## 実践
- TDD
* コーディングとでバック作業を効率的に行うために、「少しコードを書いては動かして確認する」を繰り返す　といったスタイルが望ましい
	- バグが出た場合、コードを書き足した場所　にバグが存在することが多いため、デバッグが効率的になる
	- したがって、開発端末でコーディング＋実行　ができる状態にするべし

### Test Doubles： スタブとモック, Stab and Mock
- モック(Mock)
	- SUTからその依存に向かって行われる、==外部に向かう== 出力を模倣し、さらに検証するために使われる。
		- コマンド：依存先に副作用が発生する。戻り値が無い（この副作用も、SUTの最終的な結果であるため、検証が必要）
		- 副作用が振る舞いとして外部から観測できる場合にモックとして検証する
			- e.g. 購入指示をすると、外部のメールサービスを使って、メールが送信される
		- SUTと依存のコミュニケーションの模倣だけでなく、検証も行う
		- モックを使うのはシステム間コミュニケーション（テスト対象アプリケーションの境界を超えるコミュニケーション）の場合、かつそのコミュニケーションによる副作用が外部から観察できる場合である
			- システム内コミュニケーションの確認にモックを使わない

- スタブ(Stub)
	- SUTに向かって行われる、==内部に向かう==　入力を模倣するのに使われる。
		- クエリ: 依存先に副作用を起こさない。何らかの値を返すメソッド
		- スタブはさらに３種類に分解される。そのStub vs Dummy vs Fakeの違いは、どのくらい知的に振る舞えるか？
			- Dummy: ハードコーディングされた固定値を返す. SUTのメソッドシグネチャを満たすだけ
			- Stub: 設定によって返す結果をシナリオごとに変えられる
	- SUTとスタブとのやり取りを==検証しない==
		- スタブへの呼び出しは、SUTが生み出す最終的な結果を生み出すための、途中の過程であり、最終的な結果ではないため
		- スタブへの呼び出しは、実装上の詳細である。

- ここが有名な解説サイト
	* [Test Double at XUnitPatterns\.com](http://xunitpatterns.com/Test%20Double.html)

### Individual Topics
private methodのテストを書くべきか?
- 自動テストのターゲットとなるのは「外部から見た振る舞い」であり、このブログでは「プライベートなメソッドのテストを書く必要は 無い」としている。一般的にはこの結論に私は賛成
	- https://t-wada.hatenablog.jp/entry/should-we-test-private-methods[プライベートメソッドのテストは書かないもの？ - t-wadaのブログ]
	- 内部の実装（private method)に対するテストはリファクタリングの妨げになりがちです。自動テストの助けを借りて積極的にリファクタリングを行いたいのに、その自動テストがリファクタリングの妨げになる。これはとても皮肉な状況であり、避けられれば避けたいものです。このような状況は「構造的結合が強い」と表現されます。
	- http://shoulditestprivatemethods.com/[Should I Test Private Methods?]
まとめ資料
- https://employment.en-japan.com/engineerhub/entry/2019/10/03/103000[「単体テスト」再入門！ 開発の現場でバグを確実に洗い出す最適な手法と、テストケースの作り方 - エンジニアHub｜若手Webエンジニアのキャリアを考える！]

Ginkgo

JavaのUT::
* Mockito
** https://static.javadoc.io/org.mockito/mockito-core/3.0.0/org/mockito/Mockito.html[Mockito (Mockito 3.0.0 API)]


# Integration Testing （統合テスト）
## Integration Testとは何か？
- 単体テストの持つ３つの性質のうち、１つでも損なっている場合は、統合テストである
>- 単体（Unit）　となる少量のコードを検証すること
>- 実行時間が短いこと
>- 隔離された状態で実行されること
- ほぼ全ての場合、システムがプロセス外依存と統合した状態で意図したように機能するか　を検証する
- 明確な定義はないが、一般的には、「1個下2個のプロセス外依存を扱う）
	- DBやファイルシステムなどの開発者が完全に制御できる　プロセス外依存を　対象にする
	- e.g. 一方、外部決済サービスは一般的には制御ができないため、テストダブルに置き換える

## モックのベストプラクティス
- 管理下にない依存のみをモックにする
	- ≒同じプロセス内の依存（各種ライブラリ）や管理下にある依存　の場合は、モックにせずそのまま使うべき
	- モックの置き換え対象とするのは、システムの境界に位置するものにすること
	- その依存とコミュニケーションする部分で、汎用的（ドメイン知識が入らない）。　e.g.　汎用的なMessage Busへの登録
- データベース
	- 複数のテストケースが１つのデータベースを共有するため、有るテストケースの実行が他のテストケースの実行に影響を与えてしまう可能性がある
	- したがって、下記のようにする
		- テストケースは１つずつ実行する（同時に複数テストケースを実行しない）
		- テストケースの実行によって残った不要なデータの後始末を行うこと
# E2E Testing
- すべての（もしくは、ほぼすべての）プロセス外依存を扱う
- エンドユーザ視点でシステムを検証する